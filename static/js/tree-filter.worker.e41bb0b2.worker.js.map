{"version":3,"file":"static/js/tree-filter.worker.e41bb0b2.worker.js","mappings":"AAAAA,UAAaC,IACT,MAAM,KAAEC,EAAI,MAAEC,GAAUF,EAAEC,KAEpBE,GAAgBD,IAAUA,EAAME,OAgBhCC,EAAoBA,CAACC,EAAKC,EAAMC,MAChCL,GACGK,EAAWC,OAAMC,GACtBA,EAAQC,MAAKC,IAAqB,IAApB,IAAEC,EAAG,MAAEC,GAAOF,EAC1B,MAAMG,EAAaA,CAACC,EAAGC,EAAGC,IACvBC,OAAOH,GAAGI,gBAAkBP,GAAOM,OAAOF,GAAGG,gBAAkBN,GAChEI,EAASE,cAAcC,SAAS,GAAGR,KAAOC,KAE5C,GAAmB,kBAARR,GAA4B,OAARA,EAO7B,OAAOS,EADSR,EAAKA,EAAKe,OAAS,GACRhB,EAAKC,EAAKgB,KAAK,MAN1C,IAAK,MAAOP,EAAGC,KAAMO,OAAOC,QAAQnB,GAAM,CACxC,MAAMY,EAAW,IAAIX,EAAMS,GAAGO,KAAK,KACnC,GAAIR,EAAWC,EAAGC,EAAGC,GAAW,OAAO,CACzC,CAMF,OAAO,CAAK,MAKZV,GArCckB,EAqCUxB,EApCxBC,EAAqB,GAClBuB,EAAEC,MAAM,YAAYC,KAAIC,GAC7BA,EAAKF,MAAM,aAAaC,KAAIE,IAC1B,MAAOC,EAAQC,GAAUF,EAAIH,MAAM,KACnC,OAAKI,GAAWC,EACT,CACLnB,IAAKkB,EAAO3B,OAAOgB,cACnBN,MAAOkB,EAAO5B,OAAOgB,eAHQ,IAI9B,IACAa,OAAOC,YAVMR,MAuCpB,MAAMS,EAAUA,CAACrB,EAAOD,EAAKN,KAC3B,MAAM6B,EAAc,IAAI7B,EAAMM,GAE9B,GAAc,OAAVC,GAAmC,kBAAVA,EAAoB,CAC/C,MACMuB,GADUC,MAAMC,QAAQzB,GAASA,EAAMc,KAAI,CAACX,EAAGuB,IAAM,CAACA,EAAGvB,KAAMO,OAAOC,QAAQX,IAEjFc,KAAIa,IAAA,IAAEC,EAAUC,GAASF,EAAA,OAAKN,EAAQQ,EAAUD,EAAUN,EAAY,IACtEH,QAAOW,GAAiB,OAATA,IAEZC,EAAYxC,EAAkBS,EAAOsB,EAAa5B,GAExD,OAAIqC,GAAaR,EAAaf,OAAS,EAC9B,CAAET,MAAKC,QAAOP,KAAM6B,EAAaU,QAASD,EAAWE,SAAUV,GAEjE,IACT,CAGA,OADkBhC,EAAkBS,EAAOsB,EAAa5B,GACrC,CAAEK,MAAKC,QAAOP,KAAM6B,EAAaU,SAAS,GAAS,IAAI,EAG5E,IAAIE,EAAS,GACb,GAAa,OAAT/C,GAAiC,kBAATA,EAE1B+C,GADcV,MAAMC,QAAQtC,GAAQA,EAAK2B,KAAI,CAACX,EAAGuB,IAAM,CAACA,EAAGvB,KAAMO,OAAOC,QAAQxB,IACjE2B,KAAIqB,IAAA,IAAEpC,EAAKqC,GAAID,EAAA,OAAKd,EAAQe,EAAKrC,EAAK,GAAG,IAAEoB,OAAOC,aAC5D,CACL,MAAMiB,EAAShB,EAAQlC,EAAM,OAAQ,IACjCkD,IAAQH,EAAS,CAACG,GACxB,CAEAC,YAAYJ,EAAO","sources":["services/tree-filter.worker.js"],"sourcesContent":["onmessage = (e) => {\n    const { data, query } = e.data;\n  \n    const isEmptyQuery = !query || !query.trim();\n  \n    const parseQuery = (q) => {\n      if (isEmptyQuery) return [];\n      return q.split(/\\s*&\\s*/i).map(part =>\n        part.split(/\\s*\\|\\s*/i).map(sub => {\n          const [rawKey, rawVal] = sub.split(':');\n          if (!rawKey || !rawVal) return null;\n          return {\n            key: rawKey.trim().toLowerCase(),\n            value: rawVal.trim().toLowerCase()\n          };\n        }).filter(Boolean)\n      );\n    };\n  \n    const matchesConditions = (obj, path, conditions) => {\n      if (isEmptyQuery) return true;\n      return conditions.every(orGroup =>\n        orGroup.some(({ key, value }) => {\n          const checkMatch = (k, v, fullPath) =>\n            (String(k).toLowerCase() === key && String(v).toLowerCase() === value) ||\n            fullPath.toLowerCase().includes(`${key}:${value}`);\n  \n          if (typeof obj === 'object' && obj !== null) {\n            for (const [k, v] of Object.entries(obj)) {\n              const fullPath = [...path, k].join('.');\n              if (checkMatch(k, v, fullPath)) return true;\n            }\n          } else {\n            const lastKey = path[path.length - 1];\n            return checkMatch(lastKey, obj, path.join('.'));\n          }\n  \n          return false;\n        })\n      );\n    };\n  \n    const conditions = parseQuery(query);\n  \n    const recurse = (value, key, path) => {\n      const currentPath = [...path, key];\n  \n      if (value !== null && typeof value === 'object') {\n        const entries = Array.isArray(value) ? value.map((v, i) => [i, v]) : Object.entries(value);\n        const childMatches = entries\n          .map(([childKey, childVal]) => recurse(childVal, childKey, currentPath))\n          .filter(node => node !== null);\n  \n        const selfMatch = matchesConditions(value, currentPath, conditions);\n  \n        if (selfMatch || childMatches.length > 0) {\n          return { key, value, path: currentPath, matches: selfMatch, children: childMatches };\n        }\n        return null;\n      }\n  \n      const selfMatch = matchesConditions(value, currentPath, conditions);\n      return selfMatch ? { key, value, path: currentPath, matches: true } : null;\n    };\n  \n    let result = [];\n    if (data !== null && typeof data === 'object') {\n      const roots = Array.isArray(data) ? data.map((v, i) => [i, v]) : Object.entries(data);\n      result = roots.map(([key, val]) => recurse(val, key, [])).filter(Boolean);\n    } else {\n      const single = recurse(data, 'root', []);\n      if (single) result = [single];\n    }\n  \n    postMessage(result);\n  };\n  "],"names":["onmessage","e","data","query","isEmptyQuery","trim","matchesConditions","obj","path","conditions","every","orGroup","some","_ref","key","value","checkMatch","k","v","fullPath","String","toLowerCase","includes","length","join","Object","entries","q","split","map","part","sub","rawKey","rawVal","filter","Boolean","recurse","currentPath","childMatches","Array","isArray","i","_ref2","childKey","childVal","node","selfMatch","matches","children","result","_ref3","val","single","postMessage"],"sourceRoot":""}